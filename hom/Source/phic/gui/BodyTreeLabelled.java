package phic.gui;
import phic.Current;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import phic.common.*;
import java.awt.datatransfer.StringSelection;

/**
 * Extension of tree that shows values on the right hand side.
 *
 * It contains a split pane, with tree on left, and a GridLayout pane on the right,
 * to contain the labels representing values. These values are
 * updated at regular intervals by a thread.
 *
 * It also implements a popup menu that is opened by a right-click on the tree.
 */
public class BodyTreeLabelled extends BodyTree implements SwingConstants{
  /**
   * Specifies the time interval for how often the tree labels are updated
   * with values from the engine. Value in milliseconds.
   */
  protected final int LABEL_UPDATE_TIME = 1000;


  JScrollPane jScrollPane1=new JScrollPane();

  JSplitPane jSplitPane1=new JSplitPane();
  class ScrollablePane extends JPanel implements Scrollable{
    public Dimension getPreferredScrollableViewportSize(){ return getPreferredSize();}
    public int getScrollableBlockIncrement(Rectangle visibleRect, int o, int dir){
      if(o==VERTICAL)return visibleRect.height; else return visibleRect.width;
    }
    public boolean getScrollableTracksViewportHeight(){ return false; }
    public boolean getScrollableTracksViewportWidth(){ return false; }
    public int getScrollableUnitIncrement(Rectangle visibleRect, int o, int dir){ return 10; }
  }

  JPopupMenu menu=new JPopupMenu("Node menu");

  private JMenuItem infomenuitem=new JMenuItem();

  private JMenu displaymenu=new JMenu();
  private JMenu unitmenuitem;
  JMenuItem clampmenu= new JMenuItem();
  private JPanel rightPanel=new JPanel();

  /** Special layout to ensure labels stay at top of box */
  private BorderLayout borderLayout1=new BorderLayout()/*{
    public Dimension preferredLayoutSize(java.awt.Container c){
      Dimension d=super.preferredLayoutSize(c);
      return d;
    }
    public void layoutContainer(java.awt.Container c){
      super.layoutContainer(c);
    }
  }*/  ;
  private BorderLayout borderLayout2=new BorderLayout();
  private JPanel mainPanel = new ScrollablePane();

  /**
   * This is set to true when an update is needed. When the labelspanel is
   * repainted, it checks this variable, and if it is true, newValues() is
   * called to replace the labels.
   */

  public boolean needsNewLabels=false;

  /**
   * The gridlayout panel containing the labels
   */
  private JPanel labelspanel=new JPanel(){
    public void paint(Graphics g){
      if(needsNewLabels){
        newValues();
        needsNewLabels=false;
      }
      super.paint(g);
    }
    public Dimension getPreferredSize(){
      Dimension d = super.getPreferredSize();
      d.height=Math.max(15,d.height);
      d.width=Math.max(15,d.width);
      return d;
    }
  };

  private GridLayout labelslayout=new GridLayout();

  /**
   * Rearrange the BodyTree in a split pane, and start the updater thread.
   */
  public BodyTreeLabelled(){
    removeAll();
    try{
      jbInit();
    } catch(Exception e){
      e.printStackTrace();
    }
    scrollpane.getVerticalScrollBar().setUnitIncrement(10);
    jSplitPane1.setLeftComponent(tree);
    tree.addTreeExpansionListener(tel);
    thread.start();
  }

  /** When an expansion occurs, call @link #updateValues() updateValues()*/
  TreeExpansionListener tel=new TreeExpansionListener(){
    public void treeExpanded(TreeExpansionEvent e){
      updateValues();
    }

    public void treeCollapsed(TreeExpansionEvent e){
      updateValues();
    }
  };
  /** This tells the label to repaint, setting needsNewLabels to true */

  void updateValues(){
    needsNewLabels=true;
    labelspanel.repaint();
  }

  /** The list of nodes currently displayed, corresponding to labels[] */
  Node[] nodes;

  /** The list of labels currently displayed, corresponding to nodes[] */

  JComponent[] labels;
  /**
   * Resize grid and add value labels to it.
   * The labels are generated by calling @link #createLabel(Node node)
   */

  void newValues(){
    labelslayout.setRows(tree.getRowCount());
    labelspanel.removeAll();
    nodes=new Node[tree.getRowCount()];
    labels=new JComponent[nodes.length];
    for(int i=0;i<nodes.length;i++){
      nodes[i]=getNodeForRow(i);
      labels[i]=createLabel(nodes[i]);
//      Rectangle r = tree.getRowBounds(i);
//      r.x=0; r.width=labels[i].getPreferredSize().width; r.height+=2;
      labels[i].setPreferredSize(new Dimension(labels[i].getPreferredSize().width, tree.getRowBounds(i).height));
      labelspanel.add(labels[i]);
//      labels[i].setBounds(r);
//      labels[i].setMinimumSize(new Dimension(r.width,r.height));
    }
    labelspanel.setPreferredSize(new Dimension(Math.max(200,labelspanel.getPreferredSize().
      width),tree.getPreferredSize().height));
    jScrollPane1.validate();
  }

  /**
   * If this is true, the labels will be updated regularly even when the body
   * clock is stopped.
   */

  public boolean updateWhileStopped=true;

  /** The thread calls tick every second to update the labels */
  void tick(){
    if(nodes==null||nodes.length<1||
      (!updateWhileStopped&&!Current.body.getClock().running)){
      return;
    }
    synchronized(Organ.cycleLock){
      for(int i=0;i<nodes.length;i++){
        if(labels[i] instanceof JLabel){
          ((JLabel)labels[i]).setText(nodeToString(nodes[i]));
        }
      }
    }
  }

  /** Control whether the thread is running */
  boolean running=true;

  /** The updater thread that calls @link #tick() tick() every second. */
  Thread thread=new Thread("TreeLabelUpdater"){
    public void run(){
      while(running){
        tick();
        try{
          sleep(LABEL_UPDATE_TIME);
        } catch(InterruptedException e){
          e.printStackTrace();
        }
      }
    }
  };
  JMenuItem resetmenuitem = new JMenuItem();
  JMenuItem copynamemenu = new JMenuItem();

  /**
   * This works out the best way to format a node.
   * If it is a VisibleVariable, then call @link #VisibleVariable.formatValue(double x)
   * Otherwise, it uses Quantity.toString().
   */

  String nodeToString(Node n){
    if(n!=null){
      int type=n.getType();
      if(type==Node.DOUBLE){
        VisibleVariable v=Variables.forNode(n);
        if(v!=null){
          double x=n.doubleGetVal();
          String s=v.formatValue(x,true,true);
          if(x<v.minimum){
            s+=" *L";
          } else if(x>v.maximum){
            s+=" *H";
          }
          return s;
        } else{
          return Quantity.toString(n.doubleGetVal());
        }
      }
    }
    return "";
  }

  /**
   * Return a JLabel with a string representing the node's value. The
   * string is obtained by @link #nodeToString(Node n) nodeToString(Node)
   */ JComponent createLabel(Node n){
    return new JLabel(nodeToString(n));
  }

  private void jbInit() throws Exception{
    infomenuitem.setText("Info");
    infomenuitem.addActionListener(new java.awt.event.ActionListener(){
      public void actionPerformed(ActionEvent e){
        showNodeInfo(e);
      }
    });
    displaymenu.setText("Display");
    labelslayout.setColumns(1);
    labelspanel.setLayout(labelslayout);
    labelspanel.setMinimumSize(new Dimension(15, 15));
    resetmenuitem.setText("Reset");
    resetmenuitem.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(ActionEvent e) {
        resetnodeval(e);
      }
    });
    copynamemenu.setAction(copyNameAction);
    menu.add(infomenuitem);
    menu.add(displaymenu);
    menu.add(resetmenuitem);
    menu.add(clampmenu);
    menu.add(copynamemenu);
    rightPanel.setLayout(borderLayout1);
    rightPanel.add(labelspanel,BorderLayout.NORTH);
    jSplitPane1.setRightComponent(rightPanel);
    jScrollPane1.getViewport().setView(mainPanel);
    mainPanel.setLayout(borderLayout2);
    mainPanel.add(jSplitPane1);
    this.add(jScrollPane1,BorderLayout.CENTER);
    this.tree.addMouseListener(new MouseAdapter(){
      public void mouseReleased(MouseEvent e){
        if((e.isPopupTrigger())){
          JTree tree = BodyTreeLabelled.this.tree;
          int r=tree.getRowForLocation(e.getX(),e.getY());
          if(r>=0)tree.setSelectionRow(r); // select the row first
          SimplePhicFrame f=(SimplePhicFrame)PhicApplication.frame.getJFrame();
          displaymenu.removeAll();
          if(f.selectednode==null)
            return;
          JPopupMenu pm=f.createDisplayPopup(f.selectednode);
          if(pm!=null){
            Component c[] = pm.getComponents();
            for (int i = 0; i < c.length; i++) {
              displaymenu.add(c[i]);
            }
          }
          VisibleVariable vv=tryGetSelectedVariable();
          infomenuitem.setEnabled(vv!=null);
          boolean ee=vv!=null && !(vv.node.objectGetVal() instanceof VDoubleReadOnly);
          resetmenuitem.setEnabled(ee);
          clampmenu.setEnabled(ee);
          if(unitmenuitem!=null)menu.remove(unitmenuitem);
          if(vv!=null)unitmenuitem = ((VisibleVariable)vv).createUnitsMenu();
          if(unitmenuitem!=null)menu.add(unitmenuitem);
          if(vv!=null)clampmenu.setAction(vv.clampVariable);
          menu.show(tree,e.getX(),e.getY());
        }
      }
    });
  }

  VisibleVariable tryGetSelectedVariable(){
    try{
      Node n=((SimplePhicFrame)PhicApplication.frame.getJFrame()).selectednode;
      VisibleVariable vv = Variables.forNode(n);
      return vv;
    }catch(Exception x){return null;}
  }

  void showNodeInfo(ActionEvent e){
    if(tree.getSelectionCount()>0){
      Node n=this.getNodeForRow(tree.getSelectionRows()[0]);
      VisibleVariable vv=Variables.forNode(n);
      if(vv!=null) vv.displayVariableDialog();
      else System.out.println(n+" is not a visible variable");
    }
  }

  /**
   * Calls the original BodyTree.setupNodes, then calls newValues to update the
   * right-hand panel
   */

  void refreshNodes(){
    setupNodes();
    newValues();
  }

  void resetnodeval(ActionEvent e) {
    VisibleVariable vv=tryGetSelectedVariable();
    if(vv!=null) vv.initialise();
  }
  Action copyNameAction = new AbstractAction("Copy name"){ public void actionPerformed(ActionEvent e){
      String cp="";
     if(tree.getSelectionCount()>0){
       int[] s=tree.getSelectionRows();
       for (int i = 0;i<s.length;i++){
         Node n = getNodeForRow(s[i]);
         cp=cp+n.canonicalNameReplaced();
         if(i<s.length-1) cp+=";";
       }
     }
     Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection( cp ), null);
    }
  };
}
